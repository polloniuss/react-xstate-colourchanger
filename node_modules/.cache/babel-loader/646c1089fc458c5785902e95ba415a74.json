{"ast":null,"code":"//\n//  chartparser.js\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\n//\n\n/*\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published \n  by the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  \n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  \n  You should have received a copy of the GNU General Public License\n  and the GNU Lesser General Public License along with this program.  \n  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* Mods by Torbjörn\n- Removed the toString() method from Object. Why does it still work?\n- Added a text variable (similar to rules). See \n*/\n//////////////////////////////////////////////////////////////////////\n// a logging function\n//  - uncomment if you want to debug the parsing process\nfunction LOG(str) {//console.log(\"\" + str);\n}\n\n_c = LOG;\nimport * as SRGS from './srgs'; //////////////////////////////////////////////////////////////////////\n// we need to be able to clone objects between different edges\n// borrowed from http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\n\nfunction clone(obj) {\n  if (obj == null || typeof obj != 'object') {\n    return obj;\n  }\n\n  var temp = new obj.constructor();\n\n  for (var key in obj) {\n    temp[key] = clone(obj[key]);\n  }\n\n  return temp;\n}\n\nfunction isEmpty(ob) {\n  for (var i in ob) {\n    if (ob.hasOwnProperty(i)) {\n      return false;\n    }\n  }\n\n  return true;\n} //////////////////////////////////////////////////////////////////////\n// parse chart\n// conceptually this is a set of edges, but it is optimized\n\n\nfunction Chart(numberOfWords) {\n  this.numberOfWords = numberOfWords;\n  this.passives = new Array(numberOfWords);\n  this.actives = new Array(numberOfWords);\n\n  for (var i = 0; i <= numberOfWords; i++) {\n    this.passives[i] = {};\n    this.actives[i] = {};\n  } // Chart.add(edge)\n  // add the edge to the chart, return true if the chart was changed \n  // (i.e. if the chart didn't already contain the edge)\n\n\n  this.add = function add(edge) {\n    var subchart, cat;\n\n    if (edge.isPassive) {\n      subchart = this.passives[edge.start];\n      cat = edge.lhs;\n    } else {\n      subchart = this.actives[edge.end];\n      cat = edge.next.content;\n    }\n\n    if (!(cat in subchart)) {\n      subchart[cat] = {};\n    }\n\n    if (edge in subchart[cat]) {\n      return false;\n    } else {\n      subchart[cat][edge] = edge;\n      return true;\n    }\n  }; // Chart.resultsForRule(lhs, start, end)\n  // return all parse results for the given lhs, start, and end\n  //  - start, end are optional; defaults to 0, numberOfWords\n\n\n  this.resultsForRule = function resultsForRule(lhs, start, end) {\n    start = start || 0;\n    end = end || numberOfWords;\n    var results = [];\n    var finalEdges = this.passives[start][lhs];\n\n    for (var i in finalEdges) {\n      if (finalEdges[i].end == end) {\n        results.push(finalEdges[i].out);\n      }\n    }\n\n    return results;\n  }; // Chart.allEdges() / Chart.allPassiveEdges() / Chart.allActiveEdges()\n  // return an array of all (passive/active) edges in the chart\n\n\n  this.allEdges = function allEdges() {\n    return this.allPassiveEdges().concat(this.allActiveEdges());\n  };\n\n  this.allPassiveEdges = function allPassiveEdges() {\n    var edges = [];\n\n    for (var i in this.passives) for (var j in this.passives[i]) for (var k in this.passives[i][j]) edges.push(this.passives[i][j][k]);\n\n    return edges;\n  };\n\n  this.allActiveEdges = function allActiveEdges() {\n    var edges = [];\n\n    for (var i in this.actives) for (var j in this.actives[i]) for (var k in this.actives[i][j]) edges.push(this.actives[i][j][k]);\n\n    return edges;\n  }; // Chart.statistics()\n  // return the number of edges in the chart\n\n\n  this.statistics = function statistics() {\n    var passives = this.allPassiveEdges().length;\n    var actives = this.allActiveEdges().length;\n    return {\n      nrEdges: passives + actives,\n      nrPassiveEdges: passives,\n      nrActiveEdges: actives\n    };\n  };\n} //////////////////////////////////////////////////////////////////////\n// parse edges: passive and active\n\n\n_c2 = Chart;\n\nfunction PassiveEdge(start, end, lhs, out) {\n  this.start = start;\n  this.end = end;\n  this.lhs = lhs;\n  this.out = out;\n  this.isPassive = true;\n  var str = \"[\" + start + \"-\" + end + \"] $\" + lhs + \" := \" + out;\n  this._string = str;\n\n  this.toString = function toString() {\n    return this._string;\n  };\n}\n\n_c3 = PassiveEdge;\n\nfunction ActiveEdge(start, end, lhs, next, rest, out, rules, text) {\n  this.start = start;\n  this.end = end;\n  this.lhs = lhs;\n  this.next = next;\n  this.rest = rest;\n  this.out = out;\n  this.rules = rules;\n  this.text = text;\n  this.isPassive = false;\n  var str = \"<\" + start + \"-\" + end + \"> $\" + lhs + \" -> \" + next + \", \" + rest + \" := \" + out + \" <- \" + rules;\n  this._string = str;\n\n  this.toString = function toString() {\n    return this._string;\n  };\n} //////////////////////////////////////////////////////////////////////\n// the main parsing function: a simple top-down chartparser\n//  - 'words' is an array of strings\n//  - 'grammar' is a hash table of left-hand-sides mapping to arrays of right-hand-sides\n//  - 'root' is the starting category (a string)\n//    if unspecified, use the '$root' property of the grammar\n//  - 'filter' is an optional left-corner filter \n//    (a mapping from categories/rule-refs to words)\n//    if specified, it is used when predicting new edges\n// returns the final chart\n\n\n_c4 = ActiveEdge;\nexport function parse(words, grammar, root, filter) {\n  if (!root) {\n    root = grammar.$root;\n  }\n\n  var chart = new Chart(words.length);\n  var agenda = [];\n  var leftCornerFilter;\n\n  if (filter == undefined) {\n    leftCornerFilter = function leftCornerFilter() {\n      return true;\n    };\n  } else {\n    leftCornerFilter = function leftCornerFilter(ruleref, position) {\n      var leftCorners = filter[ruleref];\n      return leftCorners ? words[position] in leftCorners : true;\n    };\n  } // add an edge to the chart and the agenda, if it does not already exist\n\n\n  function addToChart(inference, start, end, lhs, rhs, out, rules, text) {\n    var edge;\n\n    if (rhs.length > 0) {\n      var next = rhs[0];\n      var rest = rhs.slice(1);\n\n      switch (next.constructor) {\n        case Array:\n          // the next symbol is a sequence\n          addToChart(inference + \",SEQUENCE\", start, end, lhs, next.concat(rest), out, rules, text);\n          return;\n\n        case SRGS.RepeatClass:\n          // the next symbol is a repetition\n          var min = next.min;\n          var max = next.max; // skip repeat \n\n          if (min <= 0) {\n            addToChart(inference + \",SKIP\", start, end, lhs, rest, out, rules, text);\n          } // repeat \n\n\n          if (max > 0) {\n            var content = next.content;\n            var rhs = max == 1 ? [content] : [content, SRGS.Repeat(min ? min - 1 : min, max - 1, content)];\n            addToChart(inference + \",REPEAT\", start, end, lhs, rhs.concat(rest), out, rules, text);\n          }\n\n          return;\n\n        case SRGS.OneOfClass:\n          // the next symbol is a disjunction\n          var oneof = next.content;\n\n          for (var i in oneof) {\n            var rhs = oneof[i].concat(rest);\n            addToChart(inference + \",ONEOF\", start, end, lhs, rhs, out, rules, text);\n          }\n\n          return;\n\n        case SRGS.TagClass:\n          // the next symbol is a semantic action\n          out = clone(out);\n          rules = clone(rules);\n          eval(next.content);\n          addToChart(inference + \",TAG\", start, end, lhs, rest, out, rules, text);\n          return;\n      }\n\n      edge = new ActiveEdge(start, end, lhs, next, rest, out, rules, text);\n    } else {\n      edge = new PassiveEdge(start, end, lhs, out);\n    } // try to add the edge; if successful, also add it to the agenda\n\n\n    if (chart.add(edge)) {\n      LOG(\"+ \" + inference + \": \" + edge);\n      agenda.push(edge);\n    }\n  } // seed the agenda with the starting rule\n\n\n  addToChart(\"INIT\", 0, 0, root, grammar[root], {}, {}, {}); // main loop\n\n  while (agenda.length > 0) {\n    var edge = agenda.pop();\n    var start = edge.start;\n    var end = edge.end;\n    var lhs = edge.lhs;\n    var next = edge.next;\n    LOG(edge);\n\n    if (edge.isPassive) {\n      // combine\n      var actives = chart.actives[start][lhs];\n\n      for (var i in actives) {\n        var active = actives[i];\n        var rules = clone(active.rules);\n        var text = active.text;\n        text[edge.lhs] = words.slice(start, end).join(\" \");\n\n        if (typeof edge.out == 'object' && isEmpty(edge.out)) {\n          rules[edge.lhs] = text[edge.lhs];\n        } else {\n          rules[edge.lhs] = clone(edge.out);\n        }\n\n        addToChart(\"COMBINE\", active.start, end, active.lhs, active.rest, active.out, rules, text);\n      }\n    } else if (next.constructor == SRGS.RefClass) {\n      var ref = next.content; // combine\n\n      var passives = chart.passives[end][ref];\n\n      for (var i in passives) {\n        var passive = passives[i];\n        var rules = clone(edge.rules);\n        var text = edge.text;\n        rules[passive.lhs] = clone(passive.out);\n        text[passive.lhs] = passive.text;\n        addToChart(\"COMBINE\", start, passive.end, lhs, edge.rest, edge.out, rules, text);\n      } // predict\n\n\n      if (ref in grammar) {\n        if (leftCornerFilter(ref, end)) {\n          addToChart(\"PREDICT\", end, end, ref, grammar[ref], {}, {}, {});\n        }\n      }\n    } else if (next == words[end]) {\n      // scan\n      addToChart(\"SCAN\", start, end + 1, lhs, edge.rest, edge.out, edge.rules, edge.text);\n    }\n  }\n\n  return chart;\n}\n\nvar _c, _c2, _c3, _c4;\n\n$RefreshReg$(_c, \"LOG\");\n$RefreshReg$(_c2, \"Chart\");\n$RefreshReg$(_c3, \"PassiveEdge\");\n$RefreshReg$(_c4, \"ActiveEdge\");","map":{"version":3,"sources":["C:/Users/Bérénice/Documents/nodeJS/react-xstate-colourchanger/src/chartparser.js"],"names":["LOG","str","SRGS","clone","obj","temp","constructor","key","isEmpty","ob","i","hasOwnProperty","Chart","numberOfWords","passives","Array","actives","add","edge","subchart","cat","isPassive","start","lhs","end","next","content","resultsForRule","results","finalEdges","push","out","allEdges","allPassiveEdges","concat","allActiveEdges","edges","j","k","statistics","length","nrEdges","nrPassiveEdges","nrActiveEdges","PassiveEdge","_string","toString","ActiveEdge","rest","rules","text","parse","words","grammar","root","filter","$root","chart","agenda","leftCornerFilter","undefined","ruleref","position","leftCorners","addToChart","inference","rhs","slice","RepeatClass","min","max","Repeat","OneOfClass","oneof","TagClass","eval","pop","active","join","RefClass","ref","passive"],"mappings":"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","sourcesContent":["//\n//  chartparser.js\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\n//\n/*\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published \n  by the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  \n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  \n  You should have received a copy of the GNU General Public License\n  and the GNU Lesser General Public License along with this program.  \n  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* Mods by Torbjörn\n- Removed the toString() method from Object. Why does it still work?\n- Added a text variable (similar to rules). See \n*/\n\n//////////////////////////////////////////////////////////////////////\n// a logging function\n//  - uncomment if you want to debug the parsing process\nfunction LOG(str) {\n  //console.log(\"\" + str);\n}\n\nimport * as SRGS from './srgs'\n\n//////////////////////////////////////////////////////////////////////\n// we need to be able to clone objects between different edges\n// borrowed from http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\nfunction clone(obj){\n  if (obj == null || typeof(obj) != 'object') {\n    return obj;\n  }\n  var temp = new obj.constructor(); \n  for (var key in obj) {\n    temp[key] = clone(obj[key]);\n  }\n  return temp;\n}\n\n\nfunction isEmpty(ob){\n   for (var i in ob) { if(ob.hasOwnProperty(i)) {return false;}}\n  return true;\n}\n\n//////////////////////////////////////////////////////////////////////\n// parse chart\n// conceptually this is a set of edges, but it is optimized\nfunction Chart(numberOfWords) {\n  this.numberOfWords = numberOfWords;\n  this.passives = new Array(numberOfWords);\n  this.actives = new Array(numberOfWords);\n  for (var i = 0; i <= numberOfWords; i++) {\n    this.passives[i] = {};\n    this.actives[i] = {};\n  }\n\n  // Chart.add(edge)\n  // add the edge to the chart, return true if the chart was changed \n  // (i.e. if the chart didn't already contain the edge)\n  this.add = function add(edge) {\n    var subchart, cat;\n    if (edge.isPassive) {\n      subchart = this.passives[edge.start];\n      cat = edge.lhs;\n    } else {\n      subchart = this.actives[edge.end];\n      cat = edge.next.content;\n    }\n    if (!(cat in subchart)) {\n      subchart[cat] = {};\n    }\n    if (edge in subchart[cat]) {\n      return false;\n    } else {\n      subchart[cat][edge] = edge;\n      return true;\n    }\n  }\n\n  // Chart.resultsForRule(lhs, start, end)\n  // return all parse results for the given lhs, start, and end\n  //  - start, end are optional; defaults to 0, numberOfWords\n  this.resultsForRule = function resultsForRule(lhs, start, end) {\n    start = start || 0;\n    end = end || numberOfWords;\n    var results = [];\n    var finalEdges = this.passives[start][lhs];\n    for (var i in finalEdges) {\n      if (finalEdges[i].end == end) {\n\tresults.push(finalEdges[i].out);\n      }\n    }\n    return results;\n  }\n  \n  // Chart.allEdges() / Chart.allPassiveEdges() / Chart.allActiveEdges()\n  // return an array of all (passive/active) edges in the chart\n  this.allEdges = function allEdges() {\n    return this.allPassiveEdges().concat(this.allActiveEdges());\n  }\n  this.allPassiveEdges = function allPassiveEdges() {\n    var edges = [];\n    for (var i in this.passives) \n      for (var j in this.passives[i]) \n\tfor (var k in this.passives[i][j])\n\t  edges.push(this.passives[i][j][k]);\n    return edges;\n  }\n  this.allActiveEdges = function allActiveEdges() {\n    var edges = [];\n    for (var i in this.actives) \n      for (var j in this.actives[i]) \n\tfor (var k in this.actives[i][j])\n\t  edges.push(this.actives[i][j][k]);\n    return edges;\n  }\n\n  // Chart.statistics()\n  // return the number of edges in the chart\n  this.statistics = function statistics() {\n    var passives = this.allPassiveEdges().length;\n    var actives = this.allActiveEdges().length;\n    return {nrEdges: passives+actives, nrPassiveEdges: passives, nrActiveEdges: actives};\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// parse edges: passive and active\n\nfunction PassiveEdge(start, end, lhs, out) {\n  this.start = start;\n  this.end = end;\n  this.lhs = lhs;\n  this.out = out;\n  this.isPassive = true;\n\n  var str = \"[\" + start + \"-\" + end + \"] $\" + lhs + \" := \" + out;\n  this._string = str;\n  this.toString = function toString() {return this._string;} \n}\n\nfunction ActiveEdge(start, end, lhs, next, rest, out, rules, text) {\n  this.start = start;\n  this.end = end;\n  this.lhs = lhs;\n  this.next = next;\n  this.rest = rest;\n  this.out = out;\n  this.rules = rules;\n  this.text = text;\n  this.isPassive = false;\n\n  var str = \"<\" + start + \"-\" + end + \"> $\" + lhs + \" -> \" + next + \n    \", \" + rest + \" := \" + out + \" <- \" + rules;\n  this._string = str;\n  this.toString = function toString() {return this._string;} \n}\n\n\n//////////////////////////////////////////////////////////////////////\n// the main parsing function: a simple top-down chartparser\n//  - 'words' is an array of strings\n//  - 'grammar' is a hash table of left-hand-sides mapping to arrays of right-hand-sides\n//  - 'root' is the starting category (a string)\n//    if unspecified, use the '$root' property of the grammar\n//  - 'filter' is an optional left-corner filter \n//    (a mapping from categories/rule-refs to words)\n//    if specified, it is used when predicting new edges\n// returns the final chart\nexport function parse(words, grammar, root, filter) {\n  if (!root) {\n    root = grammar.$root;\n  }\n  var chart = new Chart(words.length);\n  var agenda = [];\n\n  var leftCornerFilter;\n  if (filter == undefined) {\n    leftCornerFilter = function() {return true};\n  } else {\n    leftCornerFilter = function leftCornerFilter(ruleref, position) {\n      var leftCorners = filter[ruleref];\n      return leftCorners ? words[position] in leftCorners : true;\n    }\n  }\n  \n  // add an edge to the chart and the agenda, if it does not already exist\n  function addToChart(inference, start, end, lhs, rhs, out, rules, text) {\n    var edge;\n    if (rhs.length > 0) {\n      var next = rhs[0];\n      var rest = rhs.slice(1);\n      switch (next.constructor) {\n\t\n      case Array:\n\t// the next symbol is a sequence\n\taddToChart(inference+\",SEQUENCE\", start, end, lhs, next.concat(rest), out, rules, text);\n\treturn;\n\t\n      case SRGS.RepeatClass:\n\t// the next symbol is a repetition\n\tvar min = next.min;\n\tvar max = next.max;\n\t// skip repeat \n\tif (min <= 0) {\n\t  addToChart(inference+\",SKIP\", start, end, lhs, rest, out, rules, text);\n\t}\n\t// repeat \n\tif (max > 0) {\n\t  var content = next.content;\n\t  var rhs = (max==1 ? [content] : [content, SRGS.Repeat(min ? min-1 : min, max-1, content)]);\n\t  addToChart(inference+\",REPEAT\", start, end, lhs, rhs.concat(rest), out, rules, text);\n\t}\n\treturn;\n\t\n      case SRGS.OneOfClass:\n\t// the next symbol is a disjunction\n\tvar oneof = next.content;\n\tfor (var i in oneof) {\n\t  var rhs = oneof[i].concat(rest);\n\t  addToChart(inference+\",ONEOF\", start, end, lhs, rhs, out, rules, text);\n\t} \n\treturn;\n\t\n      case SRGS.TagClass:\n\t// the next symbol is a semantic action\n\tout = clone(out);\n\trules = clone(rules);\n\teval(next.content);\n\taddToChart(inference+\",TAG\", start, end, lhs, rest, out, rules, text);\n\treturn;\n      }\n\n      edge = new ActiveEdge(start, end, lhs, next, rest, out, rules, text);\n    } else {\n      edge = new PassiveEdge(start, end, lhs, out);\n    }\n    \n    // try to add the edge; if successful, also add it to the agenda\n    if (chart.add(edge)) {\n      LOG(\"+ \" + inference + \": \" + edge);\n      agenda.push(edge);\n    }\n  }\n  \n  // seed the agenda with the starting rule\n  addToChart(\"INIT\", 0, 0, root, grammar[root], {}, {}, {});\n  \n  // main loop\n  while (agenda.length > 0) {\n    var edge = agenda.pop();\n    var start= edge.start;\n    var end  = edge.end;\n    var lhs  = edge.lhs;\n    var next = edge.next;\n    LOG(edge);\n\n    if (edge.isPassive) {\n      // combine\n      var actives = chart.actives[start][lhs];\n      for (var i in actives) {\n\tvar active = actives[i];\n\tvar rules = clone(active.rules);\n\tvar text = active.text;\n\ttext[edge.lhs] = words.slice(start, end).join(\" \");\n\tif (typeof edge.out == 'object' && isEmpty(edge.out)) {\n\t    rules[edge.lhs] = text[edge.lhs];\n\t} else {\n        rules[edge.lhs] = clone(edge.out);\n    }\n\taddToChart(\"COMBINE\", active.start, end, active.lhs, active.rest, active.out, rules, text);\n      }\n\n    } else if (next.constructor == SRGS.RefClass) {\n      var ref = next.content;\n      // combine\n      var passives = chart.passives[end][ref];\n      for (var i in passives) {\n\tvar passive = passives[i];\n\tvar rules = clone(edge.rules);\n\tvar text = edge.text;\n\trules[passive.lhs] = clone(passive.out);\n\ttext[passive.lhs] = passive.text;\n\taddToChart(\"COMBINE\", start, passive.end, lhs, edge.rest, edge.out, rules, text);\n      }\n      // predict\n      if (ref in grammar) {\n\tif (leftCornerFilter(ref, end)) {\n\t  addToChart(\"PREDICT\", end, end, ref, grammar[ref], {}, {}, {});\n\t}\n      }\n\n    } else if (next == words[end]) {\n      // scan\n      addToChart(\"SCAN\", start, end+1, lhs, edge.rest, edge.out, edge.rules, edge.text);\n    }\n  }\n\n  return chart;\n}\n"]},"metadata":{},"sourceType":"module"}