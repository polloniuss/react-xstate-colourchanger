{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _react = require('react');\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/**\r\n * Custom hook similar to useCallback, but for callbacks where the dependencies\r\n * change frequently. Ensures that references to state and props inside the\r\n * callback always get the latest values. Used to keep the `listen` and `stop`\r\n * functions in sync with the latest values of the `listening` and `supported`\r\n * state variables. See this issue for an example of why this is needed:\r\n *\r\n *   https://github.com/MikeyParton/react-speech-kit/issues/31\r\n *\r\n * Implementation taken from \"How to read an often-changing value from\r\n * useCallback?\" in the React hooks API reference:\r\n *\r\n *   https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\r\n */\n\n\nvar useEventCallback = function useEventCallback(fn, dependencies) {\n  var ref = (0, _react.useRef)(function () {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n  (0, _react.useEffect)(function () {\n    ref.current = fn;\n  }, [fn].concat(_toConsumableArray(dependencies)));\n  return (0, _react.useCallback)(function (args) {\n    var fn = ref.current;\n    return fn(args);\n  }, [ref]);\n};\n\nvar useSpeechRecognition = function useSpeechRecognition() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _props$onEnd = props.onEnd,\n      onEnd = _props$onEnd === undefined ? function () {} : _props$onEnd,\n      _props$onResult = props.onResult,\n      onResult = _props$onResult === undefined ? function () {} : _props$onResult,\n      _props$onError = props.onError,\n      onError = _props$onError === undefined ? function () {} : _props$onError;\n  var recognition = (0, _react.useRef)(null);\n\n  var _useState = (0, _react.useState)(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      listening = _useState2[0],\n      setListening = _useState2[1];\n\n  var _useState3 = (0, _react.useState)(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      supported = _useState4[0],\n      setSupported = _useState4[1];\n\n  var processResult = function processResult(event) {\n    var transcript = Array.from(event.results).map(function (result) {\n      return result[0];\n    }).map(function (result) {\n      return result.transcript;\n    }).join('');\n    onResult(transcript);\n  };\n\n  var handleError = function handleError(event) {\n    if (event.error === 'not-allowed') {\n      recognition.current.onend = function () {};\n\n      setListening(false);\n    }\n\n    onError(event);\n  };\n\n  var listen = useEventCallback(function () {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (listening || !supported) return;\n    var _args$lang = args.lang,\n        lang = _args$lang === undefined ? '' : _args$lang,\n        _args$interimResults = args.interimResults,\n        interimResults = _args$interimResults === undefined ? true : _args$interimResults,\n        _args$continuous = args.continuous,\n        continuous = _args$continuous === undefined ? false : _args$continuous,\n        _args$maxAlternatives = args.maxAlternatives,\n        maxAlternatives = _args$maxAlternatives === undefined ? 1 : _args$maxAlternatives,\n        grammars = args.grammars;\n    setListening(true);\n    recognition.current.lang = lang;\n    recognition.current.interimResults = interimResults;\n    recognition.current.onresult = processResult;\n    recognition.current.onerror = handleError;\n    recognition.current.continuous = continuous;\n    recognition.current.maxAlternatives = maxAlternatives;\n\n    if (grammars) {\n      recognition.current.grammars = grammars;\n    } // SpeechRecognition stops automatically after inactivity\n    // We want it to keep going until we tell it to stop\n\n\n    recognition.current.onend = function () {\n      return recognition.current.start();\n    };\n\n    recognition.current.start();\n  }, [listening, supported, recognition]);\n  var stop = useEventCallback(function () {\n    if (!listening || !supported) return;\n\n    recognition.current.onresult = function () {};\n\n    recognition.current.onend = function () {};\n\n    recognition.current.onerror = function () {};\n\n    setListening(false);\n    recognition.current.stop();\n    onEnd();\n  }, [listening, supported, recognition, onEnd]);\n  (0, _react.useEffect)(function () {\n    if (typeof window === 'undefined') return;\n    window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n\n    if (window.SpeechRecognition) {\n      setSupported(true);\n      recognition.current = new window.SpeechRecognition();\n    }\n  }, []);\n  return {\n    listen: listen,\n    listening: listening,\n    stop: stop,\n    supported: supported\n  };\n};\n\nexports.default = useSpeechRecognition;","map":{"version":3,"sources":["C:/Users/Bérénice/Documents/nodeJS/own_project/react-xstate-colourchanger/node_modules/react-speech-kit/dist/useSpeechRecognition.js"],"names":["Object","defineProperty","exports","value","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","TypeError","_react","require","_toConsumableArray","arr2","from","useEventCallback","fn","dependencies","ref","useRef","Error","useEffect","current","concat","useCallback","args","useSpeechRecognition","props","arguments","_props$onEnd","onEnd","_props$onResult","onResult","_props$onError","onError","recognition","_useState","useState","_useState2","listening","setListening","_useState3","_useState4","supported","setSupported","processResult","event","transcript","results","map","result","join","handleError","error","onend","listen","_args$lang","lang","_args$interimResults","interimResults","_args$continuous","continuous","_args$maxAlternatives","maxAlternatives","grammars","onresult","onerror","start","stop","window","SpeechRecognition","webkitSpeechRecognition","default"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;;AAIA,IAAIC,cAAc,GAAG,YAAY;AAAE,WAASC,aAAT,CAAuBC,GAAvB,EAA4BC,CAA5B,EAA+B;AAAE,QAAIC,IAAI,GAAG,EAAX;AAAe,QAAIC,EAAE,GAAG,IAAT;AAAe,QAAIC,EAAE,GAAG,KAAT;AAAgB,QAAIC,EAAE,GAAGC,SAAT;;AAAoB,QAAI;AAAE,WAAK,IAAIC,EAAE,GAAGP,GAAG,CAACQ,MAAM,CAACC,QAAR,CAAH,EAAT,EAAiCC,EAAtC,EAA0C,EAAEP,EAAE,GAAG,CAACO,EAAE,GAAGH,EAAE,CAACI,IAAH,EAAN,EAAiBC,IAAxB,CAA1C,EAAyET,EAAE,GAAG,IAA9E,EAAoF;AAAED,QAAAA,IAAI,CAACW,IAAL,CAAUH,EAAE,CAACb,KAAb;;AAAqB,YAAII,CAAC,IAAIC,IAAI,CAACY,MAAL,KAAgBb,CAAzB,EAA4B;AAAQ;AAAE,KAAvJ,CAAwJ,OAAOc,GAAP,EAAY;AAAEX,MAAAA,EAAE,GAAG,IAAL;AAAWC,MAAAA,EAAE,GAAGU,GAAL;AAAW,KAA5L,SAAqM;AAAE,UAAI;AAAE,YAAI,CAACZ,EAAD,IAAOI,EAAE,CAAC,QAAD,CAAb,EAAyBA,EAAE,CAAC,QAAD,CAAF;AAAiB,OAAhD,SAAyD;AAAE,YAAIH,EAAJ,EAAQ,MAAMC,EAAN;AAAW;AAAE;;AAAC,WAAOH,IAAP;AAAc;;AAAC,SAAO,UAAUF,GAAV,EAAeC,CAAf,EAAkB;AAAE,QAAIe,KAAK,CAACC,OAAN,CAAcjB,GAAd,CAAJ,EAAwB;AAAE,aAAOA,GAAP;AAAa,KAAvC,MAA6C,IAAIQ,MAAM,CAACC,QAAP,IAAmBf,MAAM,CAACM,GAAD,CAA7B,EAAoC;AAAE,aAAOD,aAAa,CAACC,GAAD,EAAMC,CAAN,CAApB;AAA+B,KAArE,MAA2E;AAAE,YAAM,IAAIiB,SAAJ,CAAc,sDAAd,CAAN;AAA8E;AAAE,GAArO;AAAwO,CAAhoB,EAArB;;AAEA,IAAIC,MAAM,GAAGC,OAAO,CAAC,OAAD,CAApB;;AAEA,SAASC,kBAAT,CAA4BrB,GAA5B,EAAiC;AAAE,MAAIgB,KAAK,CAACC,OAAN,CAAcjB,GAAd,CAAJ,EAAwB;AAAE,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWqB,IAAI,GAAGN,KAAK,CAAChB,GAAG,CAACc,MAAL,CAA5B,EAA0Cb,CAAC,GAAGD,GAAG,CAACc,MAAlD,EAA0Db,CAAC,EAA3D,EAA+D;AAAEqB,MAAAA,IAAI,CAACrB,CAAD,CAAJ,GAAUD,GAAG,CAACC,CAAD,CAAb;AAAmB;;AAAC,WAAOqB,IAAP;AAAc,GAA7H,MAAmI;AAAE,WAAON,KAAK,CAACO,IAAN,CAAWvB,GAAX,CAAP;AAAyB;AAAE;AAEnM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIwB,gBAAgB,GAAG,SAASA,gBAAT,CAA0BC,EAA1B,EAA8BC,YAA9B,EAA4C;AACjE,MAAIC,GAAG,GAAG,CAAC,GAAGR,MAAM,CAACS,MAAX,EAAmB,YAAY;AACvC,UAAM,IAAIC,KAAJ,CAAU,+CAAV,CAAN;AACD,GAFS,CAAV;AAIA,GAAC,GAAGV,MAAM,CAACW,SAAX,EAAsB,YAAY;AAChCH,IAAAA,GAAG,CAACI,OAAJ,GAAcN,EAAd;AACD,GAFD,EAEG,CAACA,EAAD,EAAKO,MAAL,CAAYX,kBAAkB,CAACK,YAAD,CAA9B,CAFH;AAIA,SAAO,CAAC,GAAGP,MAAM,CAACc,WAAX,EAAwB,UAAUC,IAAV,EAAgB;AAC7C,QAAIT,EAAE,GAAGE,GAAG,CAACI,OAAb;AACA,WAAON,EAAE,CAACS,IAAD,CAAT;AACD,GAHM,EAGJ,CAACP,GAAD,CAHI,CAAP;AAID,CAbD;;AAeA,IAAIQ,oBAAoB,GAAG,SAASA,oBAAT,GAAgC;AACzD,MAAIC,KAAK,GAAGC,SAAS,CAACvB,MAAV,GAAmB,CAAnB,IAAwBuB,SAAS,CAAC,CAAD,CAAT,KAAiB/B,SAAzC,GAAqD+B,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAhF;AACA,MAAIC,YAAY,GAAGF,KAAK,CAACG,KAAzB;AAAA,MACIA,KAAK,GAAGD,YAAY,KAAKhC,SAAjB,GAA6B,YAAY,CAAE,CAA3C,GAA8CgC,YAD1D;AAAA,MAEIE,eAAe,GAAGJ,KAAK,CAACK,QAF5B;AAAA,MAGIA,QAAQ,GAAGD,eAAe,KAAKlC,SAApB,GAAgC,YAAY,CAAE,CAA9C,GAAiDkC,eAHhE;AAAA,MAIIE,cAAc,GAAGN,KAAK,CAACO,OAJ3B;AAAA,MAKIA,OAAO,GAAGD,cAAc,KAAKpC,SAAnB,GAA+B,YAAY,CAAE,CAA7C,GAAgDoC,cAL9D;AAOA,MAAIE,WAAW,GAAG,CAAC,GAAGzB,MAAM,CAACS,MAAX,EAAmB,IAAnB,CAAlB;;AAEA,MAAIiB,SAAS,GAAG,CAAC,GAAG1B,MAAM,CAAC2B,QAAX,EAAqB,KAArB,CAAhB;AAAA,MACIC,UAAU,GAAGjD,cAAc,CAAC+C,SAAD,EAAY,CAAZ,CAD/B;AAAA,MAEIG,SAAS,GAAGD,UAAU,CAAC,CAAD,CAF1B;AAAA,MAGIE,YAAY,GAAGF,UAAU,CAAC,CAAD,CAH7B;;AAKA,MAAIG,UAAU,GAAG,CAAC,GAAG/B,MAAM,CAAC2B,QAAX,EAAqB,KAArB,CAAjB;AAAA,MACIK,UAAU,GAAGrD,cAAc,CAACoD,UAAD,EAAa,CAAb,CAD/B;AAAA,MAEIE,SAAS,GAAGD,UAAU,CAAC,CAAD,CAF1B;AAAA,MAGIE,YAAY,GAAGF,UAAU,CAAC,CAAD,CAH7B;;AAKA,MAAIG,aAAa,GAAG,SAASA,aAAT,CAAuBC,KAAvB,EAA8B;AAChD,QAAIC,UAAU,GAAGxC,KAAK,CAACO,IAAN,CAAWgC,KAAK,CAACE,OAAjB,EAA0BC,GAA1B,CAA8B,UAAUC,MAAV,EAAkB;AAC/D,aAAOA,MAAM,CAAC,CAAD,CAAb;AACD,KAFgB,EAEdD,GAFc,CAEV,UAAUC,MAAV,EAAkB;AACvB,aAAOA,MAAM,CAACH,UAAd;AACD,KAJgB,EAIdI,IAJc,CAIT,EAJS,CAAjB;AAMAnB,IAAAA,QAAQ,CAACe,UAAD,CAAR;AACD,GARD;;AAUA,MAAIK,WAAW,GAAG,SAASA,WAAT,CAAqBN,KAArB,EAA4B;AAC5C,QAAIA,KAAK,CAACO,KAAN,KAAgB,aAApB,EAAmC;AACjClB,MAAAA,WAAW,CAACb,OAAZ,CAAoBgC,KAApB,GAA4B,YAAY,CAAE,CAA1C;;AACAd,MAAAA,YAAY,CAAC,KAAD,CAAZ;AACD;;AACDN,IAAAA,OAAO,CAACY,KAAD,CAAP;AACD,GAND;;AAQA,MAAIS,MAAM,GAAGxC,gBAAgB,CAAC,YAAY;AACxC,QAAIU,IAAI,GAAGG,SAAS,CAACvB,MAAV,GAAmB,CAAnB,IAAwBuB,SAAS,CAAC,CAAD,CAAT,KAAiB/B,SAAzC,GAAqD+B,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA/E;AAEA,QAAIW,SAAS,IAAI,CAACI,SAAlB,EAA6B;AAC7B,QAAIa,UAAU,GAAG/B,IAAI,CAACgC,IAAtB;AAAA,QACIA,IAAI,GAAGD,UAAU,KAAK3D,SAAf,GAA2B,EAA3B,GAAgC2D,UAD3C;AAAA,QAEIE,oBAAoB,GAAGjC,IAAI,CAACkC,cAFhC;AAAA,QAGIA,cAAc,GAAGD,oBAAoB,KAAK7D,SAAzB,GAAqC,IAArC,GAA4C6D,oBAHjE;AAAA,QAIIE,gBAAgB,GAAGnC,IAAI,CAACoC,UAJ5B;AAAA,QAKIA,UAAU,GAAGD,gBAAgB,KAAK/D,SAArB,GAAiC,KAAjC,GAAyC+D,gBAL1D;AAAA,QAMIE,qBAAqB,GAAGrC,IAAI,CAACsC,eANjC;AAAA,QAOIA,eAAe,GAAGD,qBAAqB,KAAKjE,SAA1B,GAAsC,CAAtC,GAA0CiE,qBAPhE;AAAA,QAQIE,QAAQ,GAAGvC,IAAI,CAACuC,QARpB;AAUAxB,IAAAA,YAAY,CAAC,IAAD,CAAZ;AACAL,IAAAA,WAAW,CAACb,OAAZ,CAAoBmC,IAApB,GAA2BA,IAA3B;AACAtB,IAAAA,WAAW,CAACb,OAAZ,CAAoBqC,cAApB,GAAqCA,cAArC;AACAxB,IAAAA,WAAW,CAACb,OAAZ,CAAoB2C,QAApB,GAA+BpB,aAA/B;AACAV,IAAAA,WAAW,CAACb,OAAZ,CAAoB4C,OAApB,GAA8Bd,WAA9B;AACAjB,IAAAA,WAAW,CAACb,OAAZ,CAAoBuC,UAApB,GAAiCA,UAAjC;AACA1B,IAAAA,WAAW,CAACb,OAAZ,CAAoByC,eAApB,GAAsCA,eAAtC;;AACA,QAAIC,QAAJ,EAAc;AACZ7B,MAAAA,WAAW,CAACb,OAAZ,CAAoB0C,QAApB,GAA+BA,QAA/B;AACD,KAvBuC,CAwBxC;AACA;;;AACA7B,IAAAA,WAAW,CAACb,OAAZ,CAAoBgC,KAApB,GAA4B,YAAY;AACtC,aAAOnB,WAAW,CAACb,OAAZ,CAAoB6C,KAApB,EAAP;AACD,KAFD;;AAGAhC,IAAAA,WAAW,CAACb,OAAZ,CAAoB6C,KAApB;AACD,GA9B4B,EA8B1B,CAAC5B,SAAD,EAAYI,SAAZ,EAAuBR,WAAvB,CA9B0B,CAA7B;AAgCA,MAAIiC,IAAI,GAAGrD,gBAAgB,CAAC,YAAY;AACtC,QAAI,CAACwB,SAAD,IAAc,CAACI,SAAnB,EAA8B;;AAC9BR,IAAAA,WAAW,CAACb,OAAZ,CAAoB2C,QAApB,GAA+B,YAAY,CAAE,CAA7C;;AACA9B,IAAAA,WAAW,CAACb,OAAZ,CAAoBgC,KAApB,GAA4B,YAAY,CAAE,CAA1C;;AACAnB,IAAAA,WAAW,CAACb,OAAZ,CAAoB4C,OAApB,GAA8B,YAAY,CAAE,CAA5C;;AACA1B,IAAAA,YAAY,CAAC,KAAD,CAAZ;AACAL,IAAAA,WAAW,CAACb,OAAZ,CAAoB8C,IAApB;AACAtC,IAAAA,KAAK;AACN,GAR0B,EAQxB,CAACS,SAAD,EAAYI,SAAZ,EAAuBR,WAAvB,EAAoCL,KAApC,CARwB,CAA3B;AAUA,GAAC,GAAGpB,MAAM,CAACW,SAAX,EAAsB,YAAY;AAChC,QAAI,OAAOgD,MAAP,KAAkB,WAAtB,EAAmC;AACnCA,IAAAA,MAAM,CAACC,iBAAP,GAA2BD,MAAM,CAACC,iBAAP,IAA4BD,MAAM,CAACE,uBAA9D;;AACA,QAAIF,MAAM,CAACC,iBAAX,EAA8B;AAC5B1B,MAAAA,YAAY,CAAC,IAAD,CAAZ;AACAT,MAAAA,WAAW,CAACb,OAAZ,GAAsB,IAAI+C,MAAM,CAACC,iBAAX,EAAtB;AACD;AACF,GAPD,EAOG,EAPH;AASA,SAAO;AACLf,IAAAA,MAAM,EAAEA,MADH;AAELhB,IAAAA,SAAS,EAAEA,SAFN;AAGL6B,IAAAA,IAAI,EAAEA,IAHD;AAILzB,IAAAA,SAAS,EAAEA;AAJN,GAAP;AAMD,CAhGD;;AAkGAxD,OAAO,CAACqF,OAAR,GAAkB9C,oBAAlB","sourcesContent":["'use strict';\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n\r\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\r\n\r\nvar _react = require('react');\r\n\r\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\r\n\r\n/**\r\n * Custom hook similar to useCallback, but for callbacks where the dependencies\r\n * change frequently. Ensures that references to state and props inside the\r\n * callback always get the latest values. Used to keep the `listen` and `stop`\r\n * functions in sync with the latest values of the `listening` and `supported`\r\n * state variables. See this issue for an example of why this is needed:\r\n *\r\n *   https://github.com/MikeyParton/react-speech-kit/issues/31\r\n *\r\n * Implementation taken from \"How to read an often-changing value from\r\n * useCallback?\" in the React hooks API reference:\r\n *\r\n *   https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\r\n */\r\nvar useEventCallback = function useEventCallback(fn, dependencies) {\r\n  var ref = (0, _react.useRef)(function () {\r\n    throw new Error('Cannot call an event handler while rendering.');\r\n  });\r\n\r\n  (0, _react.useEffect)(function () {\r\n    ref.current = fn;\r\n  }, [fn].concat(_toConsumableArray(dependencies)));\r\n\r\n  return (0, _react.useCallback)(function (args) {\r\n    var fn = ref.current;\r\n    return fn(args);\r\n  }, [ref]);\r\n};\r\n\r\nvar useSpeechRecognition = function useSpeechRecognition() {\r\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n  var _props$onEnd = props.onEnd,\r\n      onEnd = _props$onEnd === undefined ? function () {} : _props$onEnd,\r\n      _props$onResult = props.onResult,\r\n      onResult = _props$onResult === undefined ? function () {} : _props$onResult,\r\n      _props$onError = props.onError,\r\n      onError = _props$onError === undefined ? function () {} : _props$onError;\r\n\r\n  var recognition = (0, _react.useRef)(null);\r\n\r\n  var _useState = (0, _react.useState)(false),\r\n      _useState2 = _slicedToArray(_useState, 2),\r\n      listening = _useState2[0],\r\n      setListening = _useState2[1];\r\n\r\n  var _useState3 = (0, _react.useState)(false),\r\n      _useState4 = _slicedToArray(_useState3, 2),\r\n      supported = _useState4[0],\r\n      setSupported = _useState4[1];\r\n\r\n  var processResult = function processResult(event) {\r\n    var transcript = Array.from(event.results).map(function (result) {\r\n      return result[0];\r\n    }).map(function (result) {\r\n      return result.transcript;\r\n    }).join('');\r\n\r\n    onResult(transcript);\r\n  };\r\n\r\n  var handleError = function handleError(event) {\r\n    if (event.error === 'not-allowed') {\r\n      recognition.current.onend = function () {};\r\n      setListening(false);\r\n    }\r\n    onError(event);\r\n  };\r\n\r\n  var listen = useEventCallback(function () {\r\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\r\n\r\n    if (listening || !supported) return;\r\n    var _args$lang = args.lang,\r\n        lang = _args$lang === undefined ? '' : _args$lang,\r\n        _args$interimResults = args.interimResults,\r\n        interimResults = _args$interimResults === undefined ? true : _args$interimResults,\r\n        _args$continuous = args.continuous,\r\n        continuous = _args$continuous === undefined ? false : _args$continuous,\r\n        _args$maxAlternatives = args.maxAlternatives,\r\n        maxAlternatives = _args$maxAlternatives === undefined ? 1 : _args$maxAlternatives,\r\n        grammars = args.grammars;\r\n\r\n    setListening(true);\r\n    recognition.current.lang = lang;\r\n    recognition.current.interimResults = interimResults;\r\n    recognition.current.onresult = processResult;\r\n    recognition.current.onerror = handleError;\r\n    recognition.current.continuous = continuous;\r\n    recognition.current.maxAlternatives = maxAlternatives;\r\n    if (grammars) {\r\n      recognition.current.grammars = grammars;\r\n    }\r\n    // SpeechRecognition stops automatically after inactivity\r\n    // We want it to keep going until we tell it to stop\r\n    recognition.current.onend = function () {\r\n      return recognition.current.start();\r\n    };\r\n    recognition.current.start();\r\n  }, [listening, supported, recognition]);\r\n\r\n  var stop = useEventCallback(function () {\r\n    if (!listening || !supported) return;\r\n    recognition.current.onresult = function () {};\r\n    recognition.current.onend = function () {};\r\n    recognition.current.onerror = function () {};\r\n    setListening(false);\r\n    recognition.current.stop();\r\n    onEnd();\r\n  }, [listening, supported, recognition, onEnd]);\r\n\r\n  (0, _react.useEffect)(function () {\r\n    if (typeof window === 'undefined') return;\r\n    window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\r\n    if (window.SpeechRecognition) {\r\n      setSupported(true);\r\n      recognition.current = new window.SpeechRecognition();\r\n    }\r\n  }, []);\r\n\r\n  return {\r\n    listen: listen,\r\n    listening: listening,\r\n    stop: stop,\r\n    supported: supported\r\n  };\r\n};\r\n\r\nexports.default = useSpeechRecognition;"]},"metadata":{},"sourceType":"script"}